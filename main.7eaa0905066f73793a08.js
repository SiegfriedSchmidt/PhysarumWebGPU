!function(){"use strict";var e,r,n,t,i={303:function(e,r,n){n.a(e,(async function(e,r){try{var t=n(189);const e={renderTime:document.getElementById("renderTime")};let i=Number(prompt("Select the number of particles","10000"));i>=1&&i<=1e7||(i=1e4);const s=document.getElementById("root");s.width=window.innerWidth,s.height=window.innerHeight;const o=new t.Z(s,e,i);await o.init()?o.update():document.body.innerHTML='<div class="not-supported"><h1>WebGPU not supported!</h1></div>',r()}catch(e){r(e)}}),1)},189:function(e,r,n){n.d(r,{Z:function(){return a}});function t(){return(new Date).getMilliseconds()}function i(e,r=0){const n=Math.max(e,r),t=Math.min(e,r);return Math.random()*(n-t)+t}function s(e){return i(...e)}function o(e){return e/180*Math.PI}var a=class{constructor(e,r,n){this.canvas=e,this.info=r,this.step=0,this.fieldResolution=[e.width,e.height],this.resolution=[e.width,e.height],this.workgroupSize=8,this.agentParamsCount=16,this.numAgents=n,this.evaporateSpeed=.05,this.diffuseSpeed=.1,this.wobbling=10,this.pheromone=.1,this.maxPheromone=3,this.twistingAngle=0,this.speedRange=[1,1],this.sensorLengthRange=[10,10],this.sensorSizeRange=[2,2],this.turnAnglesRange=[[-90,-90],[0,0],[90,90]],this.sensorAnglesRange=[[-90,-90],[0,0],[90,90]],this.wobbling=o(this.wobbling),this.twistingAngle=o(this.twistingAngle),this.turnAnglesRange=this.turnAnglesRange.map((([e,r])=>[o(e),o(r)])),this.sensorAnglesRange=this.sensorAnglesRange.map((([e,r])=>[o(e),o(r)])),this.workgroupProcessFieldCount=[Math.ceil(this.fieldResolution[0]/this.workgroupSize),Math.ceil(this.fieldResolution[1]/this.workgroupSize)],this.workgroupUpdateAgentsCount=Math.ceil(this.numAgents/(this.workgroupSize*this.workgroupSize))}update(){const e=t(),r=this.device.createCommandEncoder();this.processField(r),this.updateAgents(r),this.step++,this.render(r),this.queue.submit([r.finish()]);const n=t()-e;this.info.renderTime.innerText=`${n} ms`,this.uniformTimeArray[0]+=n,this.writeBuffer(this.uniformTimeBuffer,this.uniformTimeArray),requestAnimationFrame((()=>this.update()))}initAgents(){for(let e=0;e<this.numAgents;e++){const r=e*this.agentParamsCount,n=Math.min(this.fieldResolution[0],this.fieldResolution[1])/3;let t,o;do{t=i(-n,n),o=i(-n,n),this.agentsArray[r]=this.fieldResolution[0]/2+t,this.agentsArray[r+1]=this.fieldResolution[1]/2+o}while(t*t+o*o>n*n);this.agentsArray[r+2]=Math.random()*Math.PI*2,this.agentsArray[r+3]=s(this.speedRange),this.agentsArray[r+4]=s(this.sensorLengthRange),this.agentsArray[r+5]=s(this.sensorSizeRange),this.agentsArray[r+6]=0,this.agentsArray[r+7]=0,this.agentsArray[r+8]=s(this.turnAnglesRange[0]),this.agentsArray[r+9]=s(this.turnAnglesRange[1]),this.agentsArray[r+10]=s(this.turnAnglesRange[2]),this.agentsArray[r+11]=0,this.agentsArray[r+12]=s(this.sensorAnglesRange[0]),this.agentsArray[r+13]=s(this.sensorAnglesRange[1]),this.agentsArray[r+14]=s(this.sensorAnglesRange[2])}}processField(e){const r=e.beginComputePass();r.setPipeline(this.processFieldPipeline),r.setBindGroup(0,this.bindGroups[this.step%2]),r.dispatchWorkgroups(this.workgroupProcessFieldCount[0],this.workgroupProcessFieldCount[1]),r.end()}updateAgents(e){const r=e.beginComputePass();r.setPipeline(this.updateAgentsPipeline),r.setBindGroup(0,this.bindGroups[this.step%2]),r.dispatchWorkgroups(this.workgroupUpdateAgentsCount),r.end()}render(e){const r=e.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:.4,a:1},storeOp:"store"}]});r.setPipeline(this.renderPipeline),r.setBindGroup(0,this.bindGroups[this.step%2]),r.setVertexBuffer(0,this.vertexBuffer),r.draw(this.vertexArray.length/2),r.end()}async init(){return!!await this.initApi()&&(console.log(this.resolution,this.fieldResolution),this.initCanvas(),this.createArrays(),this.createBuffers(),this.writeBuffers(),this.createLayouts(),this.createBindings(),this.createPipelines(),!0)}createArrays(){this.vertexArray=new Float32Array([-1,-1,1,-1,1,1,-1,-1,1,1,-1,1]),this.uniformTimeArray=new Float32Array([0]),this.uniformResolutionArray=new Uint32Array(this.resolution),this.uniformFieldResolutionArray=new Uint32Array(this.fieldResolution),this.fieldStateArray=new Float32Array(this.fieldResolution[0]*this.fieldResolution[1]),this.agentsArray=new Float32Array(this.numAgents*this.agentParamsCount),this.uniformGlobalParamsArray=new Float32Array([this.evaporateSpeed,this.diffuseSpeed,this.numAgents,this.wobbling,this.pheromone,this.maxPheromone,this.twistingAngle]),this.initAgents(),console.log(this.agentsArray.byteLength)}createBuffers(){this.vertexBuffer=this.createBuffer("vertices",this.vertexArray,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),this.uniformTimeBuffer=this.createBuffer("uniform time",this.uniformTimeArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.uniformResolutionBuffer=this.createBuffer("uniform resolution",this.uniformResolutionArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.uniformFieldResolutionBuffer=this.createBuffer("uniform field resolution",this.uniformFieldResolutionArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.cellStateBuffers=[this.createBuffer("Field state A",this.fieldStateArray,GPUBufferUsage.STORAGE),this.createBuffer("Field state B",this.fieldStateArray,GPUBufferUsage.STORAGE)],this.agentsBuffer=this.createBuffer("Agents buffer",this.agentsArray,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.uniformGlobalParamsBuffer=this.createBuffer("Global params buffer",this.uniformGlobalParamsArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST)}writeBuffers(){this.writeBuffer(this.vertexBuffer,this.vertexArray),this.writeBuffer(this.uniformTimeBuffer,this.uniformTimeArray),this.writeBuffer(this.uniformResolutionBuffer,this.uniformResolutionArray),this.writeBuffer(this.uniformFieldResolutionBuffer,this.uniformFieldResolutionArray),this.writeBuffer(this.agentsBuffer,this.agentsArray),this.writeBuffer(this.uniformGlobalParamsBuffer,this.uniformGlobalParamsArray)}createLayouts(){this.vertexBufferLayout=this.createVertexLayout(2*this.vertexArray.BYTES_PER_ELEMENT,"float32x2"),this.bindGroupLayout=this.device.createBindGroupLayout({label:"Cell Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:6,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.pipelineLayout=this.device.createPipelineLayout({label:"Cell Pipeline Layout",bindGroupLayouts:[this.bindGroupLayout]})}createBindings(){const e=[{binding:0,resource:{buffer:this.uniformTimeBuffer}},{binding:1,resource:{buffer:this.uniformResolutionBuffer}},{binding:2,resource:{buffer:this.uniformFieldResolutionBuffer}},{binding:3,resource:{buffer:this.cellStateBuffers[0]}},{binding:4,resource:{buffer:this.cellStateBuffers[1]}},{binding:5,resource:{buffer:this.agentsBuffer}},{binding:6,resource:{buffer:this.uniformGlobalParamsBuffer}}],r=[...e];r[3]={binding:3,resource:{buffer:this.cellStateBuffers[1]}},r[4]={binding:4,resource:{buffer:this.cellStateBuffers[0]}},this.bindGroups=[this.device.createBindGroup({label:"Cell renderer bind group A",layout:this.bindGroupLayout,entries:e}),this.device.createBindGroup({label:"Cell renderer bind group B",layout:this.bindGroupLayout,entries:r})]}createPipelines(){const e=this.device.createShaderModule({code:"struct Global {\r\n    evaporateSpeed: f32,\r\n    diffuseSpeed: f32,\r\n    numAgents: f32,\r\n    wobbling: f32,\r\n    pheromone: f32,\r\n    maxPheromone: f32,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> time: f32;\r\n@group(0) @binding(1) var<uniform> res: vec2u;\r\n@group(0) @binding(2) var<uniform> fieldRes: vec2u;\r\n@group(0) @binding(3) var<storage> fieldState: array<f32>;\r\n@group(0) @binding(6) var<uniform> global: Global;\r\n\r\nfn getCellPos(pos: vec4f) -> u32 {\r\n    let cell = floor(pos.xy / vec2f((res / fieldRes)));\r\n    return u32(cell.x + cell.y * f32(fieldRes.x));\r\n}\r\n\r\nfn palette1(t: f32) -> vec3f {\r\n    let a = vec3f(0.5, 0.5, 0.5);\r\n    let b = vec3f(0.5, 0.5, 0.5);\r\n    let c = vec3f(0.5, 0.5, 0.5);\r\n    let d = vec3f(0.5, 0.5, 0.5);\r\n\r\n    return a + b * cos(6.28318 * (c * t + d));\r\n}\r\n\r\nfn palette2(t: f32) -> vec3f {\r\n    let a = vec3f(0.548, 0.248, 0.500);\r\n    let b = vec3f(-0.572, 0.498, 1.098);\r\n    let c = vec3f(1.158, -1.402, 0.118);\r\n    let d = vec3f(0.000, 0.333, 0.667);\r\n\r\n    return a + b * cos(6.28318 * (c * t + d));\r\n}\r\n\r\n@fragment\r\nfn fragmentMain(@builtin(position) pos: vec4f) -> @location(0) vec4f {\r\n    let cellPos = getCellPos(pos);\r\n    let color = f32(min(fieldState[cellPos], global.maxPheromone)) / global.maxPheromone;\r\n    return vec4f(palette2(color), 1);\r\n}\r\n"}),r=this.device.createShaderModule({code:"@vertex\r\nfn vertexMain(@location(0) pos: vec2f, @builtin(instance_index) instance: u32) -> @builtin(position) vec4f {\r\n  return vec4f(pos, 0, 1);\r\n}"}),n=this.device.createShaderModule({code:"const PI = 3.14159265359;\r\n\r\nstruct Agent {\r\n    pos: vec2f,\r\n    angle: f32,\r\n    speed: f32,\r\n    sensorLength: f32,\r\n    sensorSize: f32,\r\n    turnAngles: vec3f,\r\n    sensorAngles: vec3f,\r\n}\r\n\r\nstruct Global {\r\n    evaporateSpeed: f32,\r\n    diffuseSpeed: f32,\r\n    numAgents: f32,\r\n    wobbling: f32,\r\n    pheromone: f32,\r\n    maxPheromone: f32,\r\n    twistingAngle: f32,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> time: f32;\r\n@group(0) @binding(2) var<uniform> fieldRes: vec2u;\r\n@group(0) @binding(3) var<storage> fieldStateIn: array<f32>;\r\n@group(0) @binding(4) var<storage, read_write> fieldStateOut: array<f32>;\r\n@group(0) @binding(5) var<storage, read_write> agents: array<Agent>;\r\n@group(0) @binding(6) var<uniform> global: Global;\r\n\r\n\r\nfn hash(state: f32) -> f32 {\r\n    var s = u32(state);\r\n    s ^= 2747636419;\r\n    s *= 2654435769;\r\n    s ^= s >> 16;\r\n    s *= 2654435769;\r\n    s ^= s >> 16;\r\n    s *= 2654435769;\r\n    return f32(s) / 4294967295;\r\n}\r\n\r\nfn getPos(pos: vec2u) -> u32 {\r\n    return u32(pos.x + pos.y * u32(fieldRes.x));\r\n}\r\n\r\nfn checkBorder(x: i32, y: i32) -> bool {\r\n    return (x < 0 || x >= i32(fieldRes.x) || y < 0 || y >= i32(fieldRes.y));\r\n}\r\n\r\nfn getVal(x: u32, y: u32) -> f32 {\r\n    if (checkBorder(i32(x), i32(y))) {\r\n        return 0;\r\n    }\r\n    return fieldStateIn[getPos(vec2u(x, y))];\r\n}\r\n\r\nfn lerp(start: f32, end: f32, t: f32) -> f32 {\r\n    return start * (1 - t) + end * t;\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn processField(@builtin(global_invocation_id) cell: vec3u) {\r\n    if (checkBorder(i32(cell.x), i32(cell.y))) {\r\n        return;\r\n    }\r\n\r\n    let sum = getVal(cell.x, cell.y) +\r\n              getVal(cell.x + 1, cell.y + 1) +\r\n              getVal(cell.x + 1, cell.y) +\r\n              getVal(cell.x + 1, cell.y - 1) +\r\n              getVal(cell.x, cell.y - 1) +\r\n              getVal(cell.x - 1, cell.y - 1) +\r\n              getVal(cell.x - 1, cell.y) +\r\n              getVal(cell.x - 1, cell.y + 1) +\r\n              getVal(cell.x, cell.y + 1);\r\n\r\n    let pos = getPos(cell.xy);\r\n\r\n    let diffusedValue = lerp(fieldStateIn[pos], sum / 9, global.diffuseSpeed);\r\n    fieldStateOut[pos] = min(global.maxPheromone, diffusedValue * (1 - global.evaporateSpeed));\r\n}\r\n\r\nfn sense(agent: Agent, sensorAngleOffset: f32) -> f32 {\r\n    let sensorAngle = agent.angle + sensorAngleOffset;\r\n    let sensorCentre = agent.pos + vec2f(cos(sensorAngle), sin(sensorAngle)) * agent.sensorLength;\r\n    var sum: f32 = 0;\r\n    for (var x: i32 = i32(-agent.sensorSize); x <= i32(agent.sensorSize); x++) {\r\n        for (var y: i32 = i32(-agent.sensorSize); y <= i32(agent.sensorSize); y++) {\r\n            let pos = vec2i(sensorCentre) + vec2i(x, y);\r\n            if (!checkBorder(pos.x, pos.y)) {\r\n                sum += fieldStateIn[getPos(vec2u(pos))];\r\n            }\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n\r\n@compute @workgroup_size(64)\r\nfn updateAgents(@builtin(global_invocation_id) id: vec3u) {\r\n    if (id.x >= u32(global.numAgents)) {\r\n        return;\r\n    }\r\n    var agent = agents[id.x];\r\n    let random = hash(agent.pos.y * f32(fieldRes.x) + agent.pos.x + hash(f32(id.x)) * time);\r\n\r\n    let sensor1 = sense(agent, agent.sensorAngles.x);\r\n    let sensor2 = sense(agent, agent.sensorAngles.y);\r\n    let sensor3 = sense(agent, agent.sensorAngles.z);\r\n\r\n    var moveAngle: f32 = 0;\r\n    if (sensor1 > sensor2 && sensor1 > sensor3) {\r\n        moveAngle = agent.turnAngles.x;\r\n    } else if (sensor2 > sensor1 && sensor2 > sensor3) {\r\n        moveAngle = agent.turnAngles.y;\r\n    } else if (sensor3 > sensor1 && sensor2 > sensor2){\r\n        moveAngle = agent.turnAngles.z;\r\n    }\r\n\r\n    moveAngle += agent.angle + (random * 2 - 1) * global.wobbling + global.twistingAngle;\r\n    agents[id.x].angle = moveAngle;\r\n    let direction = vec2f(cos(moveAngle), sin(moveAngle));\r\n    var newPos = agent.pos + direction * agent.speed;\r\n\r\n    if (checkBorder(i32(newPos.x), i32(newPos.y))) {\r\n        newPos.x = min(f32(fieldRes.x) - 2, max(1, newPos.x));\r\n        newPos.y = min(f32(fieldRes.y) - 2, max(1, newPos.y));\r\n        agents[id.x].angle = random * 2 * PI;\r\n    }\r\n\r\n    agents[id.x].pos = newPos;\r\n    fieldStateOut[getPos(vec2u(agent.pos))] += global.pheromone;\r\n}\r\n"});this.processFieldPipeline=this.device.createComputePipeline({label:"Process field pipeline",layout:this.pipelineLayout,compute:{module:n,entryPoint:"processField"}}),this.updateAgentsPipeline=this.device.createComputePipeline({label:"Update agents pipeline",layout:this.pipelineLayout,compute:{module:n,entryPoint:"updateAgents"}}),this.renderPipeline=this.device.createRenderPipeline({label:"Render pipeline",layout:this.pipelineLayout,vertex:{module:r,entryPoint:"vertexMain",buffers:[this.vertexBufferLayout]},fragment:{module:e,entryPoint:"fragmentMain",targets:[{format:this.canvasFormat}]}})}async initApi(){try{this.adapter=await navigator.gpu.requestAdapter(),this.device=await this.adapter.requestDevice(),this.queue=this.device.queue,console.log("Adapter: ",this.adapter),console.log("Device: ",this.device)}catch(e){return console.log(e),!1}return!0}initCanvas(){this.context=this.canvas.getContext("webgpu"),this.canvasFormat=navigator.gpu.getPreferredCanvasFormat(),this.context.configure({device:this.device,format:this.canvasFormat})}createBuffer(e,r,n){return this.device.createBuffer({label:e,size:r.byteLength,usage:n})}writeBuffer(e,r){this.queue.writeBuffer(e,0,r)}createVertexLayout(e,r){return{arrayStride:e,attributes:[{format:r,offset:0,shaderLocation:0}]}}}}},s={};function o(e){var r=s[e];if(void 0!==r)return r.exports;var n=s[e]={exports:{}};return i[e](n,n.exports,o),n.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",t=function(e){e&&!e.d&&(e.d=1,e.forEach((function(e){e.r--})),e.forEach((function(e){e.r--?e.r++:e()})))},o.a=function(i,s,o){var a;o&&((a=[]).d=1);var u,f,l,g=new Set,h=i.exports,c=new Promise((function(e,r){l=r,f=e}));c[r]=h,c[e]=function(e){a&&e(a),g.forEach(e),c.catch((function(){}))},i.exports=c,s((function(i){var s;u=function(i){return i.map((function(i){if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var s=[];s.d=0,i.then((function(e){o[r]=e,t(s)}),(function(e){o[n]=e,t(s)}));var o={};return o[e]=function(e){e(s)},o}}var a={};return a[e]=function(){},a[r]=i,a}))}(i);var o=function(){return u.map((function(e){if(e[n])throw e[n];return e[r]}))},f=new Promise((function(r){(s=function(){r(o)}).r=0;var n=function(e){e!==a&&!g.has(e)&&(g.add(e),e&&!e.d&&(s.r++,e.push(s)))};u.map((function(r){r[e](n)}))}));return s.r?f:o()}),(function(e){e?l(c[n]=e):f(h),t(a)})),a&&(a.d=0)},o.d=function(e,r){for(var n in r)o.o(r,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)};o(303)}();